Teamcenter는 ENOVIA와 아키텍처 철학이 달라서 소스 코드의 위치와 개념이 조금 다릅니다.

ENOVIA(TomEE 기반)는 웹 애플리케이션 구조(WAR/Exploded)가 직관적이어서 JSP나 Java 클래스를 바로 찾아보거나 수정하기 쉬운 편입니다. 반면, **Teamcenter는 '빌드 및 배포' 과정이 필수적**인 구조이며, **Core 영역(서버)은 C++ 기반의 닫힌 소스(Compiled Binary)**로 제공됩니다.

Teamcenter의 각 영역별 OOTB 소스 위치는 다음과 같습니다.

### 1. Active Workspace (Client - Node.js/Web)
AWC는 Node.js 기반의 빌드 시스템을 사용하므로 실행 중인 서버에는 번들링(minified)된 파일만 있고, 원본 소스는 **Stage(빌드 준비 영역)**에 있습니다.

*   **위치:** `%TC_ROOT%\aws2\stage\repo`[1][2]
    *   **설명:** 이 경로 안에 OOTB 모듈들(예: `tc-aw-framework`, `aw-splm-table` 등)이 선언적(Declarative) 소스 형태(JSON, HTML, JS)로 존재합니다.
    *   **주의:** 여기 있는 파일을 직접 수정하면 안 됩니다. 본인의 커스텀 모듈(solution)을 만들고, 필요한 OOTB 소스를 참고(Reference)만 해야 합니다.
*   **개발 방식:** ENOVIA 처럼 JSP를 고치고 새로고침하는 방식이 아니라, `%TC_ROOT%\aws2\stage\src` 하위에 커스텀 모듈을 만들고 `awbuild` 명령어로 빌드하여 배포하는 방식입니다.[3][4]

### 2. Server Side (ITK - C/C++)
ENOVIA의 핵심 로직이 Java로 열려 있는 것과 달리, Teamcenter의 Core Kernel은 **비공개(Closed Source)**입니다. 즉, 로직이 담긴 `.c`나 `.cpp` 파일은 제공되지 않습니다.

*   **위치:** `%TC_ROOT%\include` (헤더 파일), `%TC_ROOT%\lib` (라이브러리)[5][6]
    *   **설명:** OOTB 동작을 뜯어볼 수는 없으며, 제공된 헤더 파일(`*.h`)을 `include` 하여 함수 원형을 보고, ITK 함수를 호출하는 방식으로 개발합니다.
    *   **개발:** Visual Studio(Windows 기준)를 사용하여 DLL을 빌드하고 Teamcenter에 로드시키는 방식입니다.[7]

### 3. Service Layer (SOA - Java)
서버와 통신하는 SOA 레이어도 소스 코드가 아닌 **JAR 라이브러리** 형태로 제공됩니다.

*   **위치:** `%TC_ROOT%\soa_client` 또는 `soa_client.zip` 내부[8][9]
    *   **설명:** `StrongType` JAR 파일들이 제공되며, 이를 Decompile 해서 내부를 보거나 API 문서를 참조해야 합니다.

### 요약: ENOVIA vs Teamcenter 비교

| 구분 | ENOVIA (TomEE) | Teamcenter |
| :--- | :--- | :--- |
| **Web Client** | JSP/Java 소스가 비교적 노출됨 | **AWC:** `%TC_ROOT%\aws2\stage\repo` (참조용 Declarative Source) |
| **Server Logic** | Java (POJO/JPO) - 소스 확인 용이 | **ITK:** 소스 없음. `include` 헤더만 제공 (Compiled DLL) |
| **Build** | Hot Swap / Restart | **AWC:** `awbuild` (Node.js 빌드) 필수 / **Server:** DLL 컴파일 및 Link |

**Tip:** IntelliJ를 쓰신다면 AWC 개발 시에도 유용하지만, OOTB 소스 분석을 할 때는 `%TC_ROOT%\aws2\stage\repo` 폴더 전체를 IDE에 프로젝트로 열어두고 'Find in Files'로 검색하면서 분석하는 것이 가장 효율적입니다.





이미 서버 환경이 있다면, 개발자 관점에서 **AWC(UI)**와 **비즈니스 로직(Backend)**을 연결하여 개발하는 표준 절차를 알려드리겠습니다.

Java 백엔드에 익숙하신 분(ENOVIA/TomEE)에게는 Teamcenter의 분리된 아키텍처(SOA Layer)가 다소 생소할 수 있으니 그 부분에 맞춰 설명합니다.

### 1. 첫 번째: UI 개발 (Active Workspace Client)
AWC는 **'Module' 단위**로 개발합니다. ENOVIA가 JSP를 수정하는 것과 달리, Node.js 기반의 빌드 시스템을 통해 모듈을 생성하고 빌드해야 합니다.

**Step 1: 개발 환경 준비 (Node.js & VS Code)**
*   `%TC_ROOT%\aws2\stage` 폴더가 AWC 소스 코드의 베이스입니다.
*   터미널(CMD)을 열고 `%TC_ROOT%\aws2\stage` 경로로 이동한 뒤 `initenv.cmd`를 실행하여 환경 변수를 로드합니다.

**Step 2: Custom Module 생성**
*   직접 폴더를 만들어도 되지만, 스크립트를 사용하는 것이 표준입니다.
*   명령어: `generateModule` (또는 버전에 따라 `npm run generateModule`)
*   프롬프트가 뜨면 **Module**을 선택하고 이름(예: `mySolution`)을 입력합니다.
*   결과: `%TC_ROOT%\aws2\stage\src\mySolution` 폴더가 생성됩니다. 이곳이 작업 공간입니다.

**Step 3: Hello World 만들기 (Declarative UI)**
AWC는 HTML/JS를 직접 짜기보다 JSON 설정(ViewModel)에 의존합니다.
*   `mySolution` 폴더 안에 `module.json`이 있고, 여기에 커맨드, 뷰 등을 등록합니다.
*   **View:** `MyHelloView.html` (HTML 태그, `<aw-button>` 같은 태그 사용)
*   **ViewModel:** `MyHelloViewModel.json` (데이터 바인딩, 이벤트 처리 로직 정의)

**Step 4: 빌드 및 확인**
*   명령어: `awbuild`
*   이 과정이 끝나야 `%TC_ROOT%\aws2\stage\repo` 등의 배포 경로로 코드가 합쳐집니다.
*   (팁) 개발 중에는 `awbuild`가 오래 걸리므로, 로컬 호스팅(`npm run start` 유사 명령, 버전에 따라 다름)을 띄워놓고 수정 사항을 바로 확인하는 방식을 씁니다.

***

### 2. 두 번째: 비즈니스 로직 개발 및 연결 (SOA & ITK)
UI(AWC)에서 버튼을 눌렀을 때, 단순히 화면 이동이 아니라 **"데이터 생성, 수정, 복잡한 연산"**이 필요하다면 **SOA(Service Oriented Architecture)**를 타야 합니다.

**방법 A: OOTB SOA 호출 (코딩 없이 JSON 설정만으로)**
대부분의 CRUD(Create, Read, Update, Delete)는 이미 지멘스가 만들어 둔 SOA 서비스가 있습니다.
*   **개발 위치:** AWC의 `ViewModel.json`
*   `"actions"` 섹션에 `TcSoaService` 타입을 정의하고, 호출할 서비스명(예: `Core-2011-06-DataManagement`, 오퍼레이션 `createRelations`)을 적으면 됩니다.
*   **장점:** 서버 코드를 짤 필요가 없습니다. UI 개발만으로 끝납니다.

**방법 B: Custom SOA 개발 (복잡한 로직 필요 시)**
OOTB 서비스로 해결 안 되는 로직(예: "객체 생성 후 특정 ERP 테이블 조회해서 속성 업데이트하고 메일 발송")은 서버 코드를 짜야 합니다.

1.  **BMIDE (Business Modeler IDE) 작업:**
    *   Eclipse 기반 BMIDE에서 **Service**를 정의합니다. (입력 파라미터, 리턴 타입 정의)
    *   "Code Generation"을 실행하면 Java/C++ 스켈레톤 코드가 생성됩니다.
2.  **Implementation (구현):**
    *   생성된 스켈레톤 파일(주로 `*Impl.java` 또는 `*Impl.cxx`)에 로직을 작성합니다.
    *   이때 **ITK 함수**를 사용하여 DB에 접근합니다.
3.  **Build & Deploy:**
    *   BMIDE에서 패키징하여 서버에 배포(Hot Deploy 또는 Cold Deploy)합니다.
4.  **AWC 연결:**
    *   이제 `ViewModel.json`에서 내가 만든 Custom SOA(예: `MyCompany-2025-01-MyService/complexLogic`)를 호출하도록 설정합니다.

### 요약: 개발자 워크플로우

1.  **요구사항 분석:** "이 기능이 단순 CRUD인가?"
    *   **Yes:** AWC `ViewModel.json`에서 **OOTB SOA** 호출 설정 (서버 개발 X).
    *   **No:** BMIDE 켜서 **Custom SOA** 설계 -> ITK 코딩 -> 서버 배포.
2.  **UI 개발:** VS Code에서 `generateModule` -> View/ViewModel 작성 -> `awbuild`.
3.  **테스트:** 브라우저에서 버튼 클릭 -> 네트워크 탭에서 SOA 요청(JSON payload) 확인.

**조언:** ENOVIA 개발자라면 Java가 편하겠지만, Teamcenter Core 퍼포먼스를 위해 서버 로직은 C++(ITK)로 짜는 경우가 많습니다. 하지만 요즘은 Java로 SOA를 구현하는 것도 지원하므로, 편한 언어(Java)로 시작해서 Custom SOA를 만들어보시는 것을 추천합니다.

### 그런데 그럼 c++을 잘하면 그냥 ITK를 직접 생성하면 되는거야? SOA는 아예 신경안 써도돼?

결론부터 말씀드리면, **Active Workspace(AWC)**와 연동하려면 **SOA는 무조건 필요합니다.** C++(ITK)만으로는 웹 브라우저와 통신할 수 없습니다.

하지만 **"SOA 코드를 일일이 짜야 한다"는 부담은 갖지 않으셔도 됩니다.** BMIDE가 지루한 연결 고리(Wrapper) 코드는 다 만들어주기 때문입니다.

이해하기 쉽게 정리해 드릴게요.

### 1. 왜 C++(ITK)만으로는 안 될까? (아키텍처 문제)
*   **AWC (Client):** 사용자의 **크롬/엣지 브라우저**에서 돌아가는 자바스크립트입니다.
*   **ITK (Server):** 데이터센터 **서버 메모리** 상에 로드된 C++ DLL입니다.
*   **문제:** 브라우저(JS)는 서버의 C++ 함수를 직접 호출할 능력이 없습니다. 중간에 누군가가 웹 요청(HTTP/JSON)을 받아서 C++ 함수로 토스해줘야 하는데, 그게 바로 **SOA**입니다.

### 2. SOA는 "껍데기", ITK는 "알맹이"
질문하신 것처럼 C++을 잘하신다면 아주 유리합니다. **실제 로직은 99% ITK(C++)로 짜기 때문입니다.**

*   **SOA의 역할:** "나 이런 함수 있어요"라고 문패를 걸고, JSON 데이터를 받아서 C++ 변수로 변환해주는 **문지기** 역할만 합니다.
*   **ITK의 역할:** 실제 데이터를 지지고 볶고 저장하는 **요리사** 역할을 합니다.

**[개발자의 실제 작업 흐름]**
1.  **BMIDE (선언):** "내 함수 이름은 `createMyItem`이고, 입력은 `String`이야"라고 정의만 합니다. (여기서 SOA 껍데기가 자동 생성됨)
2.  **Visual Studio (구현):** 생성된 C++ 파일(`*Impl.cxx`)에 들어가서 **ITK 코딩**을 신나게 합니다.
3.  **결과:** AWC에서는 SOA 이름만 부르면, 내부적으로 작성하신 C++ 코드가 돕니다.

### 3. SOA 신경 안 쓰고 ITK만 짜도 되는 경우 (예외)
웹(AWC)과 통신할 필요가 없는 **서버 내부 동작**을 개발할 때는 SOA가 필요 없습니다.

1.  **Workflow Handler (결재 라인 로직):**
    *   "승인 버튼 누르면 상태 변경하고 ERP로 전송해" 같은 로직.
    *   이미 서버 내부에서 도는 프로세스이므로 순수 C++(ITK)로만 짭니다. (**가장 많이 개발하는 영역**)
2.  **Extension (Hook):**
    *   "아이템이 저장될 때(Pre-action), 이름이 비어있으면 에러 뱉어" 같은 트리거 로직.
    *   순수 ITK입니다.
3.  **Batch Program:**
    *   밤마다 도는 마이그레이션 프로그램 등.

### 4. ENOVIA 개발자와의 차이점 (요약)
*   **ENOVIA:** JSP에서 JPO(Java)를 바로 `new Class()` 해서 부르는 느낌이라 경계가 모호합니다.
*   **Teamcenter:** 웹(AWC)과 서버(ITK) 사이에 **"SOA"라는 통역사**를 무조건 끼워야 합니다. 다만, 통역사 고용(코드 생성)은 BMIDE가 버튼 하나로 해줍니다.

**한 줄 요약:**
AWC 화면을 위한 기능이라면 **SOA 정의(껍데기) + ITK 구현(알맹이)** 세트로 가야 하고, 화면 없이 서버 혼자 도는 로직(워크플로우, 훅)이라면 **ITK**만 짜시면 됩니다.






첨부해주신 BMIDE 화면은 Teamcenter의 데이터 모델을 정의하는 가장 핵심적인 화면입니다. ENOVIA 개발자라고 하셨으니, 비교해서 설명해 드릴게요.

**화면 구성 요약 (ENOVIA 용어 매칭)**

| Teamcenter BMIDE 영역 | ENOVIA 매칭 개념 | 설명 |
| :--- | :--- | :--- |
| **Business Objects (좌측 트리)** | **Type Tree** | 데이터의 종류(Type)를 계층 구조로 관리하는 곳입니다. |
| **Main 탭 (우측 상단)** | **Type Definition** | 해당 Type의 이름, 부모(Parent), 추상화 여부 등을 설정합니다. |
| **Properties 탭 (우측 탭)** | **Attributes** | 이 Type이 가지는 속성(컬럼)을 정의합니다. |
| **Operations 탭 (우측 탭)** | **Triggers/JPO** | 생성(Create), 저장(Save) 등 이벤트 발생 시 실행할 로직을 연결합니다. |
| **Extensions (좌측 하단)** | **Global Rule/LOV** | 전역 설정, LOV(코드성 데이터), Rule 등을 관리합니다. |

***

### 화면의 각 부분 상세 설명

**1. 좌측 상단: Business Objects (데이터 모델 트리)**
현재 `Item` 아래에 **`A2_custItem`**이라는 커스텀 타입을 만드신 상태입니다.
*   **Item:** Teamcenter에서 '관리 대상'의 가장 기본 단위입니다. (ENOVIA의 Part와 유사)
*   **트리 구조:** 상속 개념이 강력합니다. `Item`에 속성을 추가하면, 그 자식인 `A2_custItem`도 자동으로 물려받습니다.
*   **파란색 `B` 아이콘:** Business Object(비즈니스 객체)를 의미합니다.

**2. 우측 메인 화면: Business Object: A2_custItem**
선택한 `A2_custItem` 타입의 기본 정보를 설정하는 곳입니다.
*   **Display Name:** 사용자 화면(AWC)에 보일 이름입니다. (예: "고객 아이템")
*   **Parent:** 부모가 `Item`입니다. 즉, Item의 모든 성질을 물려받았습니다.
*   **Item Revision:** Teamcenter는 Item 생성 시 Revision(버전) 객체가 1:1로 자동 생성됩니다. 여기서는 `A2_custItemRevision`이 세트로 묶여 있음을 보여줍니다. (ENOVIA는 Revision이 독립 객체가 아니라 하나의 리스트 개념인 것과 큰 차이)
*   **Form:** `A2_custItemMaster`라는 폼이 연결되어 있습니다. 아이템의 메타데이터(속성값)를 저장하는 별도의 그릇입니다.
*   **Type:** `Persistent`라고 되어 있죠? DB에 영구 저장되는 테이블이라는 뜻입니다. (DB Table 생성됨)

**3. 우측 탭 메뉴들 (개발 시 가장 많이 누르는 곳)**
*   **Properties:** 여기에 들어가서 `cust_material`, `cust_weight` 같은 커스텀 속성(Attribute)을 추가합니다.
*   **Operations:** 개발자가 코딩할 때 가장 중요합니다. `Create`, `Save`, `Delete` 같은 동작(Operation)에 **내가 짠 C++ 코드(Extension)**를 끼워 넣는 곳입니다. (ENOVIA의 Trigger/Action 설정과 동일)
*   **GRM Rules:** 객체 간의 관계(Relation) 제약 조건을 겁니다. "이 아이템에는 문서만 붙을 수 있다" 같은 규칙입니다.

**4. 좌측 하단: Extensions**
*   **LOV (List of Values):** 콤보 박스에 들어갈 선택지들을 관리합니다. (ENOVIA의 Range/Choice)
*   **Rules:** 명명 규칙(Naming Rule) 등을 정의합니다. (예: ID는 "PRJ-001"로 자동 채번해라)

### 개발자 팁 (IntelliJ 스타일로)
이 화면에서 모든 설정을 마치고 **저장(Ctrl+S)**을 누른다고 DB에 바로 반영되지 않습니다.
1.  **Deploy Template:** 상단 메뉴에서 `Deploy`를 해야 서버에 반영됩니다. (톰캣 재시작과 비슷)
2.  **Code Generation:** Operation 탭에서 코드를 연결했다면, `Generate Code`를 눌러야 C++ 스켈레톤 파일이 생성됩니다.

지금 화면은 아주 잘 만드셨습니다. 이제 `Properties` 탭에 가서 필요한 속성을 추가하고, `Operations` 탭에서 비즈니스 로직을 걸 준비를 하시면 됩니다.
