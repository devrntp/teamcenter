Teamcenter는 ENOVIA와 아키텍처 철학이 달라서 소스 코드의 위치와 개념이 조금 다릅니다.

ENOVIA(TomEE 기반)는 웹 애플리케이션 구조(WAR/Exploded)가 직관적이어서 JSP나 Java 클래스를 바로 찾아보거나 수정하기 쉬운 편입니다. 반면, **Teamcenter는 '빌드 및 배포' 과정이 필수적**인 구조이며, **Core 영역(서버)은 C++ 기반의 닫힌 소스(Compiled Binary)**로 제공됩니다.

Teamcenter의 각 영역별 OOTB 소스 위치는 다음과 같습니다.

### 1. Active Workspace (Client - Node.js/Web)
AWC는 Node.js 기반의 빌드 시스템을 사용하므로 실행 중인 서버에는 번들링(minified)된 파일만 있고, 원본 소스는 **Stage(빌드 준비 영역)**에 있습니다.

*   **위치:** `%TC_ROOT%\aws2\stage\repo`[1][2]
    *   **설명:** 이 경로 안에 OOTB 모듈들(예: `tc-aw-framework`, `aw-splm-table` 등)이 선언적(Declarative) 소스 형태(JSON, HTML, JS)로 존재합니다.
    *   **주의:** 여기 있는 파일을 직접 수정하면 안 됩니다. 본인의 커스텀 모듈(solution)을 만들고, 필요한 OOTB 소스를 참고(Reference)만 해야 합니다.
*   **개발 방식:** ENOVIA 처럼 JSP를 고치고 새로고침하는 방식이 아니라, `%TC_ROOT%\aws2\stage\src` 하위에 커스텀 모듈을 만들고 `awbuild` 명령어로 빌드하여 배포하는 방식입니다.[3][4]

### 2. Server Side (ITK - C/C++)
ENOVIA의 핵심 로직이 Java로 열려 있는 것과 달리, Teamcenter의 Core Kernel은 **비공개(Closed Source)**입니다. 즉, 로직이 담긴 `.c`나 `.cpp` 파일은 제공되지 않습니다.

*   **위치:** `%TC_ROOT%\include` (헤더 파일), `%TC_ROOT%\lib` (라이브러리)[5][6]
    *   **설명:** OOTB 동작을 뜯어볼 수는 없으며, 제공된 헤더 파일(`*.h`)을 `include` 하여 함수 원형을 보고, ITK 함수를 호출하는 방식으로 개발합니다.
    *   **개발:** Visual Studio(Windows 기준)를 사용하여 DLL을 빌드하고 Teamcenter에 로드시키는 방식입니다.[7]

### 3. Service Layer (SOA - Java)
서버와 통신하는 SOA 레이어도 소스 코드가 아닌 **JAR 라이브러리** 형태로 제공됩니다.

*   **위치:** `%TC_ROOT%\soa_client` 또는 `soa_client.zip` 내부[8][9]
    *   **설명:** `StrongType` JAR 파일들이 제공되며, 이를 Decompile 해서 내부를 보거나 API 문서를 참조해야 합니다.

### 요약: ENOVIA vs Teamcenter 비교

| 구분 | ENOVIA (TomEE) | Teamcenter |
| :--- | :--- | :--- |
| **Web Client** | JSP/Java 소스가 비교적 노출됨 | **AWC:** `%TC_ROOT%\aws2\stage\repo` (참조용 Declarative Source) |
| **Server Logic** | Java (POJO/JPO) - 소스 확인 용이 | **ITK:** 소스 없음. `include` 헤더만 제공 (Compiled DLL) |
| **Build** | Hot Swap / Restart | **AWC:** `awbuild` (Node.js 빌드) 필수 / **Server:** DLL 컴파일 및 Link |

**Tip:** IntelliJ를 쓰신다면 AWC 개발 시에도 유용하지만, OOTB 소스 분석을 할 때는 `%TC_ROOT%\aws2\stage\repo` 폴더 전체를 IDE에 프로젝트로 열어두고 'Find in Files'로 검색하면서 분석하는 것이 가장 효율적입니다.





이미 서버 환경이 있다면, 개발자 관점에서 **AWC(UI)**와 **비즈니스 로직(Backend)**을 연결하여 개발하는 표준 절차를 알려드리겠습니다.

Java 백엔드에 익숙하신 분(ENOVIA/TomEE)에게는 Teamcenter의 분리된 아키텍처(SOA Layer)가 다소 생소할 수 있으니 그 부분에 맞춰 설명합니다.

### 1. 첫 번째: UI 개발 (Active Workspace Client)
AWC는 **'Module' 단위**로 개발합니다. ENOVIA가 JSP를 수정하는 것과 달리, Node.js 기반의 빌드 시스템을 통해 모듈을 생성하고 빌드해야 합니다.

**Step 1: 개발 환경 준비 (Node.js & VS Code)**
*   `%TC_ROOT%\aws2\stage` 폴더가 AWC 소스 코드의 베이스입니다.
*   터미널(CMD)을 열고 `%TC_ROOT%\aws2\stage` 경로로 이동한 뒤 `initenv.cmd`를 실행하여 환경 변수를 로드합니다.

**Step 2: Custom Module 생성**
*   직접 폴더를 만들어도 되지만, 스크립트를 사용하는 것이 표준입니다.
*   명령어: `generateModule` (또는 버전에 따라 `npm run generateModule`)
*   프롬프트가 뜨면 **Module**을 선택하고 이름(예: `mySolution`)을 입력합니다.
*   결과: `%TC_ROOT%\aws2\stage\src\mySolution` 폴더가 생성됩니다. 이곳이 작업 공간입니다.

**Step 3: Hello World 만들기 (Declarative UI)**
AWC는 HTML/JS를 직접 짜기보다 JSON 설정(ViewModel)에 의존합니다.
*   `mySolution` 폴더 안에 `module.json`이 있고, 여기에 커맨드, 뷰 등을 등록합니다.
*   **View:** `MyHelloView.html` (HTML 태그, `<aw-button>` 같은 태그 사용)
*   **ViewModel:** `MyHelloViewModel.json` (데이터 바인딩, 이벤트 처리 로직 정의)

**Step 4: 빌드 및 확인**
*   명령어: `awbuild`
*   이 과정이 끝나야 `%TC_ROOT%\aws2\stage\repo` 등의 배포 경로로 코드가 합쳐집니다.
*   (팁) 개발 중에는 `awbuild`가 오래 걸리므로, 로컬 호스팅(`npm run start` 유사 명령, 버전에 따라 다름)을 띄워놓고 수정 사항을 바로 확인하는 방식을 씁니다.

***

### 2. 두 번째: 비즈니스 로직 개발 및 연결 (SOA & ITK)
UI(AWC)에서 버튼을 눌렀을 때, 단순히 화면 이동이 아니라 **"데이터 생성, 수정, 복잡한 연산"**이 필요하다면 **SOA(Service Oriented Architecture)**를 타야 합니다.

**방법 A: OOTB SOA 호출 (코딩 없이 JSON 설정만으로)**
대부분의 CRUD(Create, Read, Update, Delete)는 이미 지멘스가 만들어 둔 SOA 서비스가 있습니다.
*   **개발 위치:** AWC의 `ViewModel.json`
*   `"actions"` 섹션에 `TcSoaService` 타입을 정의하고, 호출할 서비스명(예: `Core-2011-06-DataManagement`, 오퍼레이션 `createRelations`)을 적으면 됩니다.
*   **장점:** 서버 코드를 짤 필요가 없습니다. UI 개발만으로 끝납니다.

**방법 B: Custom SOA 개발 (복잡한 로직 필요 시)**
OOTB 서비스로 해결 안 되는 로직(예: "객체 생성 후 특정 ERP 테이블 조회해서 속성 업데이트하고 메일 발송")은 서버 코드를 짜야 합니다.

1.  **BMIDE (Business Modeler IDE) 작업:**
    *   Eclipse 기반 BMIDE에서 **Service**를 정의합니다. (입력 파라미터, 리턴 타입 정의)
    *   "Code Generation"을 실행하면 Java/C++ 스켈레톤 코드가 생성됩니다.
2.  **Implementation (구현):**
    *   생성된 스켈레톤 파일(주로 `*Impl.java` 또는 `*Impl.cxx`)에 로직을 작성합니다.
    *   이때 **ITK 함수**를 사용하여 DB에 접근합니다.
3.  **Build & Deploy:**
    *   BMIDE에서 패키징하여 서버에 배포(Hot Deploy 또는 Cold Deploy)합니다.
4.  **AWC 연결:**
    *   이제 `ViewModel.json`에서 내가 만든 Custom SOA(예: `MyCompany-2025-01-MyService/complexLogic`)를 호출하도록 설정합니다.

### 요약: 개발자 워크플로우

1.  **요구사항 분석:** "이 기능이 단순 CRUD인가?"
    *   **Yes:** AWC `ViewModel.json`에서 **OOTB SOA** 호출 설정 (서버 개발 X).
    *   **No:** BMIDE 켜서 **Custom SOA** 설계 -> ITK 코딩 -> 서버 배포.
2.  **UI 개발:** VS Code에서 `generateModule` -> View/ViewModel 작성 -> `awbuild`.
3.  **테스트:** 브라우저에서 버튼 클릭 -> 네트워크 탭에서 SOA 요청(JSON payload) 확인.

**조언:** ENOVIA 개발자라면 Java가 편하겠지만, Teamcenter Core 퍼포먼스를 위해 서버 로직은 C++(ITK)로 짜는 경우가 많습니다. 하지만 요즘은 Java로 SOA를 구현하는 것도 지원하므로, 편한 언어(Java)로 시작해서 Custom SOA를 만들어보시는 것을 추천합니다.



